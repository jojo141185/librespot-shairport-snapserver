# File: .github/workflows/build-and-publish.yml

name: Fork: Build and Publish Docker Images # Renamed workflow name

on:
  workflow_dispatch: # Manual trigger
  release:
    types: [published] # Trigger on new GitHub releases
  pull_request:
    types: [opened, synchronize, reopened] # Trigger on PR changes for testing PR branches
  push:
    branches:
      - development
      - master
    tags:
      - 'v*.*.*' # Optional: build tags explicitly if not covered by release trigger

env:
  # The base image repository name without suffix
  REGISTRY_IMAGE: ghcr.io/${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read # Needed for checkout
      packages: write # Needed to push images to GHCR
    strategy:
      # Allow other matrix jobs to continue even if one fails
      fail-fast: false
      matrix:
        # Define the matrix of platforms and Dockerfiles to build
        include:
          # Alpine Builds
          - platform: linux/amd64
            dockerfile: alpine.dockerfile
            image_suffix: -alpine # Suffix to differentiate images (e.g., ...-alpine)
          - platform: linux/arm64
            dockerfile: alpine.dockerfile
            image_suffix: -alpine
          # Debian Builds
          - platform: linux/amd64
            dockerfile: debian.dockerfile
            image_suffix: -debian # Suffix to differentiate images (e.g., ...-debian)
          - platform: linux/arm64
            dockerfile: debian.dockerfile
            image_suffix: -debian
        # Add more platforms or dockerfiles here if needed

    steps:
      - name: Prepare variables for digest tracking
        run: |
          # Create a unique name based on platform and Dockerfile for artifacts
          platform_dockerfile_pair="${{ matrix.platform//\//- }}-${{ matrix.dockerfile/.dockerfile/ }}"
          echo "PLATFORM_DOCKERFILE_PAIR=${platform_dockerfile_pair}" >> $GITHUB_ENV
          # Create the specific image name including suffix (e.g., ghcr.io/...-alpine)
          echo "SPECIFIC_IMAGE_NAME=${{ env.REGISTRY_IMAGE }}${{ matrix.image_suffix }}" >> $GITHUB_ENV

      - name: Checkout Code
        # Use v4 for current practices
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch complete history for correct tagging

      # Apply the CPU limit reversion patch to both Dockerfiles
      # NOTE: This modifies the checked-out files ONLY within this workflow run.
      # It does not change the files in your Git repository.
      - name: Revert CPU limit patch
        run: |
          sed -i 's/(( \$(nproc) -1 ))/(nproc)/g' './alpine.dockerfile' './debian.dockerfile'
        # You might want to add a check here to ensure the sed command succeeded
        # or that the modified files have the expected content.

      - name: Set up QEMU (for multi-arch builds)
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx (for building and pushing)
        # Use the latest v3 version
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata (tags, labels) for SPECIFIC image (${{ matrix.dockerfile }})
        # Generate tags and labels specific to this platform and Dockerfile (e.g., ghcr.io/...-alpine)
        id: meta_specific_${{ env.PLATFORM_DOCKERFILE_PAIR }} # Unique ID using the prepared variable
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.SPECIFIC_IMAGE_NAME }} # Use the specific image name with suffix
          tags: |
            # Tag with branch name (e.g., development, master) for push events
            type=ref,event=push,pattern={{branch}}
            # Tag with PR number for pull_request events
            type=ref,event=pull_request,pattern=pr-{{pr.number}}
            # Tag with SHA for manual triggers or release events (optional)
            type=sha,enable=${{ github.event_name == 'workflow_dispatch' || github.event_name == 'release' }}
            # SemVer tags only for GitHub releases
            type=semver,pattern={{version}},event=release
            type=semver,pattern={{major}}.{{minor}},event=release
            type=semver,pattern={{major}},event=release
            # Add other specific tags if needed

      - name: Login to GitHub Container Registry
        # This step is idempotent and safe to run in each matrix job
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push SPECIFIC Docker image (${{ matrix.dockerfile }} for ${{ matrix.platform }})
        id: build_specific_${{ env.PLATFORM_DOCKERFILE_PAIR }} # Unique ID using the prepared variable
        uses: docker/build-push-action@v6
        with:
          context: . # Build context is the root of the repository
          file: ${{ matrix.dockerfile }} # Use the Dockerfile specified by the matrix
          platforms: ${{ matrix.platform }} # Build for the platform specified by the matrix
          # Scope the cache by OS and Dockerfile type to avoid conflicts
          cache-from: type=gha,scope=${{ runner.os }}-${{ matrix.dockerfile/.dockerfile/ }}
          cache-to: type=gha,scope=${{ runner.os }}-${{ matrix.dockerfile/.dockerfile/ }},mode=max
          provenance: false # Consider setting this to true for better security/transparency
          labels: ${{ steps.meta_specific_${{ env.PLATFORM_DOCKERFILE_PAIR }}.outputs.labels }} # Use labels from this specific matrix job
          tags: ${{ steps.meta_specific_${{ env.PLATFORM_DOCKERFILE_PAIR }}.outputs.tags }} # Use tags from this specific matrix job
          # Push individual images by digest. The manifest job combines them later.
          # Push only if the event is from the owner's repository (push, release)
          # or a PR from the same repository, or a manual trigger.
          # This prevents pushing images from PRs coming from external forks.
          push: ${{ github.event.pull_request.head.repo.full_name == github.repository || github.event_name == 'push' || github.event_name == 'release' || github.event_name == 'workflow_dispatch' }}
          # Crucially, push-by-digest=true ensures the individual platform images are available via their digest
          outputs: type=image,name=${{ env.SPECIFIC_IMAGE_NAME }},push-by-digest=true,name-canonical=true,push=${{ github.event.pull_request.head.repo.full_name == github.repository || github.event_name == 'push' || github.event_name == 'release' || github.event_name == 'workflow_dispatch' }}


      # Export the full Image@Digest reference for this specific image build
      - name: Export specific image name and digest
        run: |
          mkdir -p /tmp/image-infos
          # Full reference format: ghcr.io/user/repo-suffix@sha256:...
          specific_image_digest="${{ env.SPECIFIC_IMAGE_NAME }}@${{ steps.build_specific_${{ env.PLATFORM_DOCKERFILE_PAIR }}.outputs.digest }}"
          # Save the reference to a file named after platform and dockerfile in a temporary directory
          echo "${specific_image_digest}" > "/tmp/image-infos/${{ env.PLATFORM_DOCKERFILE_PAIR }}.imageinfo"

      # Upload the file containing the image reference as an artifact
      - name: Upload specific image info artifact
        uses: actions/upload-artifact@v4
        with:
          # Unique artifact name per matrix job
          name: image-info-${{ env.PLATFORM_DOCKERFILE_PAIR }}
          path: /tmp/image-infos/*.imageinfo
          if-no-files-found: error
          retention-days: 1 # Keep artifact for 1 day


  merge_manifest:
    # This job requires all "build" matrix jobs to complete successfully
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read # Needed to download artifacts
      packages: write # Needed to push the manifest list to GHCR
    # Run this job only if ALL build jobs were successful AND
    # if the event is relevant for creating a multi-arch manifest list (Push, Release, Manual).
    # Excludes PRs from external forks.
    if: |
      always() # Ensure needs.build.result is available regardless of build success
      && needs.build.result == 'success' # Only run if ALL build jobs were successful
      && github.actor != 'dependabot[bot]' # Exclude dependabot
      && ( github.event_name == 'push' || github.event_name == 'release' || github.event_name == 'workflow_dispatch' ) # Only for Push, Release, Manual triggers

    steps:
      - name: Download all image info artifacts
        uses: actions/download-artifact@v4
        with:
          # Download all artifacts whose names start with "image-info-"
          pattern: image-info-*
          path: /tmp/downloaded-digests # Directory to download artifacts into
          merge-multiple: true # Merge contents of matching artifacts into this directory

      - name: Prepare combined image list for manifest tool
        id: image_list
        run: |
          # Find all .imageinfo files, read their content, and create a space-separated list of references
          IMAGE_REFS=""
          # Use find and while loop for robustness with special characters/whitespace
          find /tmp/downloaded-digests -type file -name "*.imageinfo" -print0 | while IFS= read -r -d $'\0' info_file; do
            image_digest_ref=$(cat "$info_file") # Format: ghcr.io/user/repo-suffix@sha256:...
            IMAGE_REFS+=" ${image_digest_ref}" # Append to string (with a leading space)
          done

          # Check if any image references were found
          if [ -z "${IMAGE_REFS}" ]; then
            echo "::error::No image references found in downloaded artifacts. Manifest creation skipped."
            exit 1 # Fail the job if no image info was collected
          fi
          # Trim leading/trailing whitespace and output the list of references
          echo "::set-output name=refs::$(echo ${IMAGE_REFS} | xargs)"
          echo "Found image refs: $(echo ${IMAGE_REFS} | xargs)" # Print for debug
        shell: bash # Ensure bash is used for find, while loop, xargs etc.


      - name: Set up Docker Buildx (for manifest creation)
        # Required for imagetools create
        uses: docker/setup-buildx-action@v3

      - name: Docker meta for BASE image (creating manifest tags)
        id: meta_base
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.REGISTRY_IMAGE }} # This is the base name WITHOUT suffix (ghcr.io/jojo141185/...)
          # These tags apply to the multi-arch manifest list of the base image
          tags: |
            # Tag with branch name (e.g., development, master) for push events
            type=ref,event=push,pattern={{branch}}
            # Tag with SemVer tags only for releases (vX.Y.Z)
            type=semver,pattern={{version}},event=release
            type=semver,pattern={{major}}.{{minor}},event=release
            type=semver,pattern={{major}},event=release
            # Tag 'latest' on push to master/main branch OR on release
            # Adjust 'master'/'main' check if your default branch is named differently
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v') }}
            # Tag with SHA for manual trigger (optional, could be excluded for manifests)
            type=sha,enable=${{ github.event_name == 'workflow_dispatch' }}


      - name: Login to GitHub Container Registry (for manifest push)
        # Needed to push the manifest list
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create manifest list and push BASE image
        # This step runs only once after all individual builds are done and artifacts collected
        run: |
          # Get the list of image references from the output of the previous step
          IMAGE_REFS="${{ steps.image_list.outputs.refs }}"
          # Get the tags generated by the metadata action for the base image
          TAGS=$(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON")

          if [ -z "${IMAGE_REFS}" ]; then
              echo "Error: No image references provided. Manifest creation skipped."
              exit 1 # Should be caught by the image_list step, but double-check
          fi
          # It's possible no tags were generated for certain events (e.g., PRs which are filtered by 'if')
          # If no tags are generated but the 'if' condition passed, something might be wrong
          if [ -z "${TAGS}" ]; then
              echo "Error: No tags provided by metadata action for base image. Manifest creation skipped."
              # Depending on requirements, you might want to exit 1 here.
              # Given the 'if' condition on the job, this might indicate a configuration error.
              exit 1
          fi

          echo "Creating manifest list for ${{ env.REGISTRY_IMAGE }} with tags: ${TAGS}"
          # docker buildx imagetools create expects the tags, then the base image name, then the list of Image@Digest references to combine
          docker buildx imagetools create ${TAGS} \
            ${{ env.REGISTRY_IMAGE }} ${IMAGE_REFS}

        env:
          # Make the JSON output of the metadata action available as an environment variable for jq
          DOCKER_METADATA_OUTPUT_JSON: ${{ steps.meta_base.outputs.json }}

      - name: Inspect BASE image manifest (Optional)
        # Inspect the created manifest list to verify it
        run: |
          # Try to get the first generated tag for inspection (e.g., branch name or latest)
          # This is just for verification in the workflow logs
          BASE_IMAGE_TAG=$(jq -r '.tags[0]' <<< "$DOCKER_METADATA_OUTPUT_JSON")
          if [ -n "$BASE_IMAGE_TAG" ] && [ "$BASE_IMAGE_TAG" != "null" ]; then # Check if tag exists and is not null
             echo "Inspecting ${{ env.REGISTRY_IMAGE }}:${BASE_IMAGE_TAG}"
             docker buildx imagetools inspect ${{ env.REGISTRY_IMAGE }}:${BASE_IMAGE_TAG}
          else
             echo "No tags generated or found for inspection."
          fi
        env:
          DOCKER_METADATA_OUTPUT_JSON: ${{ steps.meta_base.outputs.json }} # Needed for jq